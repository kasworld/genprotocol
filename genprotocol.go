// Copyright 2015,2016,2017,2018,2019 SeukWon Kang (kasworld@gmail.com)
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
)

func makeGenComment() string {
	return fmt.Sprintf("// Code generated by \"%s %s\"\n",
		filepath.Base(os.Args[0]), strings.Join(os.Args[1:], " "))
}

// loadEnumWithComment load list of enum + comment
func loadEnumWithComment(filename string) ([][]string, error) {
	fd, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer fd.Close()
	rtn := make([][]string, 0)
	rd := bufio.NewReader(fd)
	for {
		line, err := rd.ReadString('\n')
		line = strings.TrimSpace(line)
		if len(line) != 0 && line[0] != '#' {
			s2 := strings.SplitN(line, " ", 2)
			if len(s2) == 1 {
				s2 = append(s2, "")
			}
			rtn = append(rtn, s2)
		}
		if err != nil { // eof
			break
		}
	}
	return rtn, nil
}

// saveTo save go source with format, saved file may need goimport
func saveTo(outdata *bytes.Buffer, buferr error, outfilename string) error {
	if buferr != nil {
		fmt.Printf("fail %v %v\n", outfilename, buferr)
		return buferr
	}
	src, err := format.Source(outdata.Bytes())
	if err != nil {
		fmt.Println(outdata)
		fmt.Printf("fail %v %v\n", outfilename, err)
		return err
	}
	if werr := ioutil.WriteFile(outfilename, src, 0644); werr != nil {
		fmt.Printf("fail %v %v\n", outfilename, werr)
		return werr
	}
	fmt.Printf("goimports -w %v\n", outfilename)
	return nil
}

var (
	ver     = flag.String("ver", "", "protocol version")
	prefix  = flag.String("prefix", "", "protocol prefix")
	basedir = flag.String("basedir", "", "base directory")
)

func main() {
	flag.Parse()

	if *prefix == "" {
		fmt.Println("prefix not set")
	}
	if *ver == "" {
		fmt.Println("ver not set")
	}
	if *basedir == "" {
		fmt.Println("base dir not set")
	}

	dirToMake := []string{
		"_handlersp",
		"_handlereq",
		"_handlenoti",
		"_callsendrecv",
		"_msgp",
		"_json",
		"_error",
		"_gendata",
		"_idcmd",
		"_idnoti",
		"_obj",
		"_packet",
		"_version",
		"_conntcp",
		"_connwasm",
		"_connwsgorilla",
		"_loopwsgorilla",
		"_looptcp",
		"_statnoti",
		"_statcallapi",
		"_statserveapi",
		"_statapierror",
	}

	cmddatafile := path.Join(*basedir, *prefix+"_gendata", "command.data")
	cmddata, err := loadEnumWithComment(cmddatafile)
	if err != nil {
		fmt.Printf("fail to load %v %v\n", cmddatafile, err)
		return
	}
	notidatafile := path.Join(*basedir, *prefix+"_gendata", "noti.data")
	notidata, err := loadEnumWithComment(notidatafile)
	if err != nil {
		fmt.Printf("fail to load %v %v\n", notidatafile, err)
		return
	}
	errordatafile := path.Join(*basedir, *prefix+"_gendata", "error.data")
	errordata, err := loadEnumWithComment(errordatafile)
	if err != nil {
		fmt.Printf("fail to load %v %v\n", errordatafile, err)
		return
	}

	for _, v := range dirToMake {
		os.MkdirAll(path.Join(*basedir, *prefix+v), os.ModePerm)
	}

	buf, err := buildVersion(*prefix+"_version", *ver)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_version", "version_gen.go"))

	buf, err = buildDataCode(*prefix+"_idcmd", "CommandID", cmddata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_idcmd", "command_gen.go"))

	buf, err = buildDataCode(*prefix+"_idnoti", "NotiID", notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_idnoti", "noti_gen.go"))

	buf, err = buildErrorCode(*prefix+"_error", "ErrorCode", errordata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_error", "error_gen.go"))

	buf, err = buildPacket(*prefix, *prefix+"_packet")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_packet", "packet_gen.go"))

	buf, err = buildObjTemplate(*prefix, *prefix+"_obj", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_obj", "objtemplate_gen.go"))

	buf, err = buildMSGP(*prefix, *prefix+"_msgp", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_msgp", "serialize_gen.go"))

	buf, err = buildJSON(*prefix, *prefix+"_json", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_json", "serialize_gen.go"))

	buf, err = buildRecvRspFnObjTemplate(*prefix, *prefix+"_handlersp", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_handlersp", "fnobjtemplate_gen.go"))

	buf, err = buildRecvRspFnBytesTemplate(*prefix, *prefix+"_handlersp", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_handlersp", "fnbytestemplate_gen.go"))

	buf, err = buildRecvNotiFnObjTemplate(*prefix, *prefix+"_handlenoti", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_handlenoti", "fnobjtemplate_gen.go"))

	buf, err = buildRecvNotiFnBytesTemplate(*prefix, *prefix+"_handlenoti", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_handlenoti", "fnbytestemplate_gen.go"))

	buf, err = buildCallSendRecv(*prefix, *prefix+"_callsendrecv", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_callsendrecv", "callsendrecv_gen.go"))

	buf, err = buildRecvReqFnObjTemplate(*prefix, *prefix+"_handlereq", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_handlereq", "fnobjtemplate_gen.go"))

	buf, err = buildRecvReqFnBytesAPITemplate(*prefix, *prefix+"_handlereq", cmddata, notidata)
	saveTo(buf, err, path.Join(*basedir, *prefix+"_handlereq", "fnbytestemplate_gen.go"))

	buf, err = buildConnTCP(*prefix, *prefix+"_conntcp")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_conntcp", "conntcp_gen.go"))

	buf, err = buildConnWasm(*prefix, *prefix+"_connwasm")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_connwasm", "connwasm_gen.go"))

	buf, err = buildConnWSGorilla(*prefix, *prefix+"_connwsgorilla")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_connwsgorilla", "connwsgorilla_gen.go"))

	buf, err = buildLoopWSGorilla(*prefix, *prefix+"_loopwsgorilla")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_loopwsgorilla", "loopwsgorilla_gen.go"))

	buf, err = buildLoopTCP(*prefix, *prefix+"_looptcp")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_looptcp", "looptcp_gen.go"))

	buf, err = buildStatNoti(*prefix, *prefix+"_statnoti")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_statnoti", "statnoti_gen.go"))

	buf, err = buildStatCallAPI(*prefix, *prefix+"_statcallapi")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_statcallapi", "statcallapi_gen.go"))

	buf, err = buildStatServeAPI(*prefix, *prefix+"_statserveapi")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_statserveapi", "statserveapi_gen.go"))

	buf, err = buildStatAPIError(*prefix, *prefix+"_statapierror")
	saveTo(buf, err, path.Join(*basedir, *prefix+"_statapierror", "statapierror_gen.go"))
}

func buildDataCode(pkgname string, enumtype string, data [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s
		import "fmt"
		type %v uint16 // use in packet header, DO NOT CHANGE
	`, pkgname, enumtype)

	fmt.Fprintf(&buf, "const (\n")
	for i, v := range data {
		if i == 0 {
			fmt.Fprintf(&buf, "%v %v = iota // %v \n", v[0], enumtype, v[1])
		} else {
			fmt.Fprintf(&buf, "%v // %v\n", v[0], v[1])
		}
	}
	fmt.Fprintf(&buf, `
	%[1]s_Count int = iota 
	)
	var _%[1]s_str = map[%[1]s]string{
	`, enumtype)

	for _, v := range data {
		fmt.Fprintf(&buf, "%v : \"%v\", \n", v[0], v[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	fmt.Fprintf(&buf, `
	func (e %[1]s) String() string {
		if s, exist := _%[1]s_str[e]; exist {
			return s
		}
		return fmt.Sprintf("%[1]s%%d", uint16(e))
	}
	`, enumtype)

	return &buf, nil
}

func buildErrorCode(pkgname string, enumtype string, data [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s
		import "fmt"
		type %v uint16 // use in packet header, DO NOT CHANGE
	`, pkgname, enumtype)

	fmt.Fprintf(&buf, "const (\n")
	for i, v := range data {
		if i == 0 {
			fmt.Fprintf(&buf, "%v %v = iota // %v \n", v[0], enumtype, v[1])
		} else {
			fmt.Fprintf(&buf, "%v // %v\n", v[0], v[1])
		}
	}
	fmt.Fprintf(&buf, `
	%[1]s_Count int = iota 
	)
	var _%[1]s_str = map[%[1]s]string{
	`, enumtype)

	for _, v := range data {
		fmt.Fprintf(&buf, "%v : \"%v\", \n", v[0], v[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	fmt.Fprintf(&buf, `
	func (e %[1]s) String() string {
		if s, exist := _%[1]s_str[e]; exist {
			return s
		}
		return fmt.Sprintf("%[1]s%%d", uint16(e))
	}
	// implement error interface
	func (e %[1]s) Error() string {
		return "%[2]s." + e.String()
	}
	`, enumtype, pkgname)

	return &buf, nil
}

func buildVersion(pkgname string, ver string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	const ProtocolVersion = "%[2]s"
	`, pkgname, ver)
	return &buf, nil
}

func buildMSGP(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s
	`, pkgname)
	fmt.Fprintf(&buf, `
	// MarshalBodyFn marshal body and append to oldBufferToAppend
	// and return newbuffer, body type(marshaltype,compress,encryption), error
	func MarshalBodyFn(body interface{}, oldBuffToAppend []byte) ([]byte, byte, error) {
		newBuffer, err := body.(msgp.Marshaler).MarshalMsg(oldBuffToAppend)
		return newBuffer, 0, err
	}

	func UnmarshalPacket(h %[1]s_packet.Header,  bodyData []byte) (interface{}, error) {
		switch h.FlowType {
		case %[1]s_packet.Request:
			if int(h.Cmd) >= len(ReqUnmarshalMap) {
				return nil, fmt.Errorf("unknown request command: %%v %%v", 
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd))
			}
			return ReqUnmarshalMap[h.Cmd](h,bodyData)

		case %[1]s_packet.Response:
			if int(h.Cmd) >= len(RspUnmarshalMap) {
				return nil, fmt.Errorf("unknown response command: %%v %%v", 
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd))
			}
			return RspUnmarshalMap[h.Cmd](h,bodyData)

		case %[1]s_packet.Notification:
			if int(h.Cmd) >= len(NotiUnmarshalMap) {
				return nil, fmt.Errorf("unknown notification command: %%v %%v", 
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd))
			}
			return NotiUnmarshalMap[h.Cmd](h,bodyData)
		}
		return nil, fmt.Errorf("unknown packet FlowType %%v",h.FlowType)
	}
	`, prefix, ver)

	const unmarshalMapHeader = `
	var %[2]s = [...]func(h %[1]s_packet.Header,bodyData []byte) (interface{}, error) {
	`
	const unmarshalMapBody = "%[1]s_idcmd:  unmarshal_%[2]s%[3]s, \n"

	// req map
	fmt.Fprintf(&buf, unmarshalMapHeader, prefix, "ReqUnmarshalMap")
	for _, v := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s:  unmarshal_Req%[2]s, \n", prefix, v[0])
	}
	fmt.Fprintf(&buf, "}\n")

	// rsp map
	fmt.Fprintf(&buf, unmarshalMapHeader, prefix, "RspUnmarshalMap")
	for _, v := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s:  unmarshal_Rsp%[2]s, \n", prefix, v[0])
	}
	fmt.Fprintf(&buf, "}\n")

	fmt.Fprintf(&buf, unmarshalMapHeader, prefix, "NotiUnmarshalMap")
	// noti map
	for _, v := range notidata {
		fmt.Fprintf(&buf, "%[1]s_idnoti.%[2]s:  unmarshal_Noti%[2]s, \n", prefix, v[0])
	}
	fmt.Fprintf(&buf, "}\n")

	const unmarshalFunc = `
	func unmarshal_%[1]s%[2]s(h %[3]s_packet.Header,bodyData []byte) (interface{}, error) {
		var args %[3]s_obj.%[1]s%[2]s_data
		if _, err := args.UnmarshalMsg(bodyData); err != nil {
			return nil, err
		}
		return &args, nil
	}
	`
	for _, v := range cmddata {
		fmt.Fprintf(&buf, unmarshalFunc, "Req", v[0], prefix)
		fmt.Fprintf(&buf, unmarshalFunc, "Rsp", v[0], prefix)
	}
	for _, v := range notidata {
		fmt.Fprintf(&buf, unmarshalFunc, "Noti", v[0], prefix)
	}
	return &buf, nil
}

func buildJSON(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s
	`, pkgname)
	fmt.Fprintf(&buf, `
	// marshal body and append to oldBufferToAppend
	// and return newbuffer, body type(marshaltype,compress,encryption), error
	func MarshalBodyFn(body interface{}, oldBuffToAppend []byte) ([]byte, byte, error) {
		var newBuffer []byte
		mdata, err := json.Marshal(body)
		if err == nil {
			newBuffer = append(oldBuffToAppend, mdata...)
		}
		return newBuffer, 0, err
	}
	
	func UnmarshalPacket(h %[1]s_packet.Header,  bodyData []byte) (interface{}, error) {
		switch h.FlowType {
		case %[1]s_packet.Request:
			if int(h.Cmd) >= len(ReqUnmarshalMap) {
				return nil, fmt.Errorf("unknown request command: %%v %%v", 
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd))
			}
			return ReqUnmarshalMap[h.Cmd](h,bodyData)

		case %[1]s_packet.Response:
			if int(h.Cmd) >= len(RspUnmarshalMap) {
				return nil, fmt.Errorf("unknown response command: %%v %%v", 
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd))
			}
			return RspUnmarshalMap[h.Cmd](h,bodyData)

		case %[1]s_packet.Notification:
			if int(h.Cmd) >= len(NotiUnmarshalMap) {
				return nil, fmt.Errorf("unknown notification command: %%v %%v", 
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd))
			}
			return NotiUnmarshalMap[h.Cmd](h,bodyData)
		}
		return nil, fmt.Errorf("unknown packet FlowType %%v",h.FlowType)
	}
	`, prefix, ver)

	const unmarshalMapHeader = `
	var %[2]s = [...]func(h %[1]s_packet.Header,bodyData []byte) (interface{}, error) {
	`
	const unmarshalMapBody = "%[1]s_idcmd:  unmarshal_%[2]s%[3]s, \n"

	// req map
	fmt.Fprintf(&buf, unmarshalMapHeader, prefix, "ReqUnmarshalMap")
	for _, v := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s:  unmarshal_Req%[2]s, \n", prefix, v[0])
	}
	fmt.Fprintf(&buf, "}\n")

	// rsp map
	fmt.Fprintf(&buf, unmarshalMapHeader, prefix, "RspUnmarshalMap")
	for _, v := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s:  unmarshal_Rsp%[2]s, \n", prefix, v[0])
	}
	fmt.Fprintf(&buf, "}\n")

	fmt.Fprintf(&buf, unmarshalMapHeader, prefix, "NotiUnmarshalMap")
	// noti map
	for _, v := range notidata {
		fmt.Fprintf(&buf, "%[1]s_idnoti.%[2]s:  unmarshal_Noti%[2]s, \n", prefix, v[0])
	}
	fmt.Fprintf(&buf, "}\n")

	const unmarshalFunc = `
	func unmarshal_%[1]s%[2]s(h %[3]s_packet.Header,bodyData []byte) (interface{}, error) {
		var args %[3]s_obj.%[1]s%[2]s_data
		if err := json.Unmarshal(bodyData, &args) ; err != nil {
			return nil, err
		}
		return &args, nil
	}
	`
	for _, v := range cmddata {
		fmt.Fprintf(&buf, unmarshalFunc, "Req", v[0], prefix)
		fmt.Fprintf(&buf, unmarshalFunc, "Rsp", v[0], prefix)
	}
	for _, v := range notidata {
		fmt.Fprintf(&buf, unmarshalFunc, "Noti", v[0], prefix)
	}
	return &buf, nil
}

func buildRecvRspFnObjTemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	/* obj base demux fn map template 
	`, pkgname)
	fmt.Fprintf(&buf,
		"\nvar DemuxRsp2ObjFnMap = [...]func(me interface{}, hd %[1]s_packet.Header, body interface{}) error {\n",
		prefix)
	for _, f := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s : objRecvRspFn_%[2]s,\n", prefix, f[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	for _, f := range cmddata {
		fmt.Fprintf(&buf, `
	func objRecvRspFn_%[2]s(me interface{}, hd %[1]s_packet.Header, body interface{}) error {
		robj , ok := body.(*%[1]s_obj.Rsp%[2]s_data)
		if !ok {
			return fmt.Errorf("packet mismatch %%v", body )
		}
		return fmt.Errorf("Not implemented %%v", robj)
	}
	`, prefix, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildRecvRspFnBytesTemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	/* bytes base demux fn map template 
	`, pkgname)
	fmt.Fprintf(&buf,
		"\nvar DemuxRsp2BytesFnMap = [...]func(me interface{}, hd %[1]s_packet.Header, rbody []byte) error {\n",
		prefix)
	for _, f := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s : bytesRecvRspFn_%[2]s,\n", prefix, f[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	for _, f := range cmddata {
		fmt.Fprintf(&buf, `
	func bytesRecvRspFn_%[2]s(me interface{}, hd %[1]s_packet.Header, rbody []byte) error {
		robj, err := %[1]s_json.UnmarshalPacket(hd, rbody)
		if err != nil {
			return  fmt.Errorf("Packet type miss match %%v", rbody)
		}
		recved , ok := robj.(*%[1]s_obj.Rsp%[2]s_data)
		if !ok {
			return fmt.Errorf("packet mismatch %%v", robj )
		}
		return fmt.Errorf("Not implemented %%v", recved)
	}
	`, prefix, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildRecvNotiFnObjTemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	/* obj base demux fn map template 
	`, pkgname)

	fmt.Fprintf(&buf,
		"\nvar DemuxNoti2ObjFnMap = [...]func(me interface{}, hd %[1]s_packet.Header, body interface{}) error {\n",
		prefix)
	for _, f := range notidata {
		fmt.Fprintf(&buf, "%[1]s_idnoti.%[2]s : objRecvNotiFn_%[2]s,\n", prefix, f[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	for _, f := range notidata {
		fmt.Fprintf(&buf, `
	func objRecvNotiFn_%[2]s(me interface{}, hd %[1]s_packet.Header, body interface{}) error {
		robj , ok := body.(*%[1]s_obj.Noti%[2]s_data)
		if !ok {
			return fmt.Errorf("packet mismatch %%v", body )
		}
		return fmt.Errorf("Not implemented %%v", robj)
	}
	`, prefix, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildRecvNotiFnBytesTemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	/* bytes base demux fn map template 
	`, pkgname)

	fmt.Fprintf(&buf,
		"\nvar DemuxNoti2ByteFnMap = [...]func(me interface{}, hd %[1]s_packet.Header, rbody []byte) error {\n",
		prefix)
	for _, f := range notidata {
		fmt.Fprintf(&buf, "%[1]s_idnoti.%[2]s : bytesRecvNotiFn_%[2]s,\n", prefix, f[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	for _, f := range notidata {
		fmt.Fprintf(&buf, `
	func bytesRecvNotiFn_%[2]s(me interface{}, hd %[1]s_packet.Header, rbody []byte) error {
		robj, err := %[1]s_json.UnmarshalPacket(hd, rbody)
		if err != nil {
			return fmt.Errorf("Packet type miss match %%v", rbody)
		}
		recved , ok := robj.(*%[1]s_obj.Noti%[2]s_data)
		if !ok {
			return fmt.Errorf("packet mismatch %%v", robj )
		}
		return fmt.Errorf("Not implemented %%v", recved)
	}
	`, prefix, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildCallSendRecv(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	type C2SConnectI interface {
		SendRecv(
			cmd %[2]s_idcmd.CommandID, body interface{}) (
			%[2]s_packet.Header, interface{}, error)
	
		CheckAPI(hd %[2]s_packet.Header) error
	}
	`, pkgname, prefix)
	for _, f := range cmddata {
		fmt.Fprintf(&buf, `
			func Call_%[2]s(%[1]sc C2SConnectI,arg *%[1]s_obj.Req%[2]s_data) (*%[1]s_obj.Rsp%[2]s_data, error) {
				if arg == nil {
					arg = &%[1]s_obj.Req%[2]s_data{}
				}
				hd, rsp, err := %[1]sc.SendRecv(
					%[1]s_idcmd.%[2]s,
					arg)
				if err != nil {
					return nil, err
				}
				robj := rsp.(*%[1]s_obj.Rsp%[2]s_data)
				return robj, %[1]sc.CheckAPI(hd)
			}
			`, prefix, f[0])
	}
	return &buf, nil
}

func buildPacket(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	`, pkgname)
	fmt.Fprintf(&buf, `
	type FlowType byte // packet flow type
	
	const (
		invalid FlowType = iota // make uninitalized packet error
		Request // Request for request packet (response packet expected)
		Response // Response is reply of request packet
		Notification // Notification is just send and forget packet
	)
	var _FlowType_str = map[FlowType]string{
		invalid:      "invalid",
		Request:      "Request",
		Response:     "Response",
		Notification: "Notification",
	}
	func (e FlowType) String() string {
		if s, exist := _FlowType_str[e]; exist {
			return s
		}
		return fmt.Sprintf("FlowType%%d", byte(e))
	}

	///////////////////////////////////////////////////////////////////////////////

	const (
		// MaxBodyLen set to max body len, affect send/recv buffer size
		MaxBodyLen = 0xfffff

		// HeaderLen fixed size of header
		HeaderLen = 4 + 4 + 2 + 2 + 1 + 1 + 2

		// MaxPacketLen max total packet size byte of raw packet
		MaxPacketLen = HeaderLen + MaxBodyLen
	)

	func (pk Packet) String() string {
		return fmt.Sprintf("Packet[%%v %%+v]", pk.Header, pk.Body)
	}

	// Packet is header + body as object (not byte list)
	type Packet struct {
		Header Header
		Body   interface{}
	}

	func (h Header) String() string {
		switch h.FlowType {
		default:
			return fmt.Sprintf(
				"Header[%%v:%%v ID:%%v Error:%%v bodyLen:%%v Compress:%%v Fill:%%v]",
				h.FlowType, h.Cmd, h.ID, h.ErrorCode, h.bodyLen, h.bodyType, h.Fill)
		case invalid:
			return fmt.Sprintf(
				"Header[%%v:%%v ID:%%v Error:%%v bodyLen:%%v Compress:%%v Fill:%%v]",
				h.FlowType, h.Cmd, h.ID, h.ErrorCode, h.bodyLen, h.bodyType, h.Fill)
		case Request:
			return fmt.Sprintf(
				"Header[%%v:%%v ID:%%v Error:%%v bodyLen:%%v Compress:%%v Fill:%%v]",
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd), h.ID, h.ErrorCode, h.bodyLen, h.bodyType, h.Fill)
		case Response:
			return fmt.Sprintf(
				"Header[%%v:%%v ID:%%v Error:%%v bodyLen:%%v Compress:%%v Fill:%%v]",
				h.FlowType, %[1]s_idcmd.CommandID(h.Cmd), h.ID, h.ErrorCode, h.bodyLen, h.bodyType, h.Fill)
		case Notification:
			return fmt.Sprintf(
				"Header[%%v:%%v ID:%%v Error:%%v bodyLen:%%v Compress:%%v Fill:%%v]",
				h.FlowType, %[1]s_idnoti.NotiID(h.Cmd), h.ID, h.ErrorCode, h.bodyLen, h.bodyType, h.Fill)
		}
	}

	// Header is fixed size header of packet
	type Header struct {
		bodyLen   uint32              // set at marshal(Packet2Bytes)
		ID        uint32              // sender set, unique id per packet (wrap around reuse)
		Cmd       uint16              // sender set, application demux received packet
		ErrorCode %[1]s_error.ErrorCode // sender set, Response error
		FlowType  FlowType            // sender set, flow control, Request, Response, Notification
		bodyType  byte                // set at marshal(Packet2Bytes), body compress, marshal type
		Fill      uint16              // sender set, any data
	}
	
	// MakeHeaderFromBytes unmarshal header from bytelist
	func MakeHeaderFromBytes(buf []byte) Header {
		var h Header
		h.bodyLen = binary.LittleEndian.Uint32(buf[0:4])
		h.ID = binary.LittleEndian.Uint32(buf[4:8])
		h.Cmd = binary.LittleEndian.Uint16(buf[8:10])
		h.ErrorCode = %[1]s_error.ErrorCode(binary.LittleEndian.Uint16(buf[10:12]))
		h.FlowType = FlowType(buf[12])
		h.bodyType = buf[13]
		h.Fill = binary.LittleEndian.Uint16(buf[14:16])
		return h
	}
		
	func (h Header) toBytesAt(buf []byte) {
		binary.LittleEndian.PutUint32(buf[0:4], h.bodyLen)
		binary.LittleEndian.PutUint32(buf[4:8], h.ID)
		binary.LittleEndian.PutUint16(buf[8:10], h.Cmd)
		binary.LittleEndian.PutUint16(buf[10:12], uint16(h.ErrorCode))
		buf[12] = byte(h.FlowType)
		buf[13] = h.bodyType
		binary.LittleEndian.PutUint16(buf[14:16], h.Fill)
	}
	
	// ToByteList marshal header to bytelist
	func (h Header) ToByteList() []byte {
		buf := make([]byte, HeaderLen)
		h.toBytesAt(buf)
		return buf
	}
	
	// GetBodyLenFromHeaderBytes return packet body len from bytelist of header
	func GetBodyLenFromHeaderBytes(buf []byte) uint32 {
		return binary.LittleEndian.Uint32(buf[0:4])
	}
	
	// BodyLen return bodylen field
	func (h *Header) BodyLen() uint32 {
		return h.bodyLen
	}
	
	// BodyType return bodyType field
	func (h *Header) BodyType() byte {
		return h.bodyType
	}

	///////////////////////////////////////////////////////////////////////////////

	// func NewSendPacketBuffer() []byte {
	// 	return make([]byte, MaxPacketLen)
	// }

	func NewRecvPacketBuffer() *RecvPacketBuffer {
		pb := &RecvPacketBuffer{
			RecvBuffer: make([]byte, MaxPacketLen),
			RecvLen:    0,
		}
		return pb
	}

	// RecvPacketBuffer used for packet receive
	type RecvPacketBuffer struct {
		RecvBuffer []byte
		RecvLen    int
	}

	// NewRecvPacketBufferByData make RecvPacketBuffer by exist data
	func NewRecvPacketBufferByData(rdata []byte) *RecvPacketBuffer {
		pb := &RecvPacketBuffer{
			RecvBuffer: rdata,
			RecvLen:    len(rdata),
		}
		return pb
	}

	// GetHeader make header and return
	// if data is insufficent, return empty header
	func (pb *RecvPacketBuffer) GetHeader() Header {
		if !pb.IsHeaderComplete() {
			return Header{}
		}
		header := MakeHeaderFromBytes(pb.RecvBuffer)
		return header
	}

	// GetBodyBytes return body ready to unmarshal.
	func (pb *RecvPacketBuffer) GetBodyBytes() ([]byte, error) {
		if !pb.IsPacketComplete() {
			return nil, fmt.Errorf("packet not complete")
		}
		header := pb.GetHeader()
		body := pb.RecvBuffer[HeaderLen : HeaderLen+int(header.bodyLen)]
		return body, nil
	}

	// GetHeaderBody return header and Body as bytelist
	// application need demux by header.FlowType, header.Cmd
	// unmarshal body with header.bodyType
	// and check header.ID(if response packet)
	func (pb *RecvPacketBuffer) GetHeaderBody() (Header, []byte, error) {
		if !pb.IsPacketComplete() {
			return Header{}, nil, fmt.Errorf("packet not complete")
		}
		header := pb.GetHeader()
		body, err := pb.GetBodyBytes()
		return header, body, err
	}

	// IsHeaderComplete check recv data is sufficient for header
	func (pb *RecvPacketBuffer) IsHeaderComplete() bool {
		return pb.RecvLen >= HeaderLen
	}

	// IsPacketComplete check recv data is sufficient for packet
	func (pb *RecvPacketBuffer) IsPacketComplete() bool {
		if !pb.IsHeaderComplete() {
			return false
		}
		bodylen := GetBodyLenFromHeaderBytes(pb.RecvBuffer)
		return pb.RecvLen == HeaderLen+int(bodylen)
	}

	// NeedRecvLen return need data len for header or body
	func (pb *RecvPacketBuffer) NeedRecvLen() int {
		if !pb.IsHeaderComplete() {
			return HeaderLen
		}
		bodylen := GetBodyLenFromHeaderBytes(pb.RecvBuffer)
		return HeaderLen + int(bodylen)
	}

	// Read use for partial recv like tcp read
	func (pb *RecvPacketBuffer) Read(conn io.Reader) error {
		toRead := pb.NeedRecvLen()
		for pb.RecvLen < toRead {
			n, err := conn.Read(pb.RecvBuffer[pb.RecvLen:toRead])
			if err != nil {
				return err
			}
			pb.RecvLen += n
		}
		return nil
	}

	// Packet2Bytes make packet to bytelist
	// marshalBodyFn append marshaled(+compress) body to buffer and return total buffer, bodyType, error
	// set Packet.Header.bodyLen, Packet.Header.bodyType
	// return bytelist, error
	func Packet2Bytes(pk *Packet,
		marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
		oldbuf []byte,
	) ([]byte, error) {
		newbuf, bodytype, err := marshalBodyFn(pk.Body, oldbuf)
		if err != nil {
			return nil, err
		}
		bodyLen := len(newbuf) - HeaderLen
		if bodyLen > MaxBodyLen {
			return nil,
				fmt.Errorf("fail to serialize large packet %%v, %%v", pk.Header, bodyLen)
		}
		pk.Header.bodyType = bodytype
		pk.Header.bodyLen = uint32(bodyLen)
		pk.Header.toBytesAt(newbuf)
		return newbuf, nil
	}
	
	///////////////////////////////////////////////////////////////////////////////
	type Buffer []byte
	
	type Pool struct {
		mutex    sync.Mutex
		buffPool []Buffer
		count    int
	}
	
	func NewPool(count int) *Pool {
		return &Pool{
			buffPool: make([]Buffer, 0, count),
			count:    count,
		}
	}
	
	func (p *Pool) String() string {
		return fmt.Sprintf("PacketPool[%%v %%v/%%v]",
			len(p.buffPool), p.count,
		)
	}
	
	func (p *Pool) Get() Buffer {
		p.mutex.Lock()
		defer p.mutex.Unlock()
		var rtn Buffer
		if l := len(p.buffPool); l > 0 {
			rtn = p.buffPool[l-1]
			p.buffPool = p.buffPool[:l-1]
		} else {
			rtn = make(Buffer, HeaderLen, MaxPacketLen)
		}
		return rtn
	}
	
	func (p *Pool) Put(pb Buffer) {
		p.mutex.Lock()
		defer p.mutex.Unlock()
		if len(p.buffPool) < p.count {
			p.buffPool = append(p.buffPool, pb[:HeaderLen])
		}
	}
		`, prefix)
	return &buf, nil
}

func buildObjTemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s
		/* protocol template 
		`, pkgname)

	for _, f := range cmddata {
		fmt.Fprintf(&buf, `
		type Req%[2]s_data struct {
			Dummy uint8
		}
		type Rsp%[2]s_data struct {
			Dummy uint8
		}
		`, prefix, f[0])
	}
	for _, f := range notidata {
		fmt.Fprintf(&buf, `
		type Noti%[1]s_data struct {
			Dummy uint8
		}
		`, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildRecvReqFnObjTemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	/* obj base demux fn map template 
	`, pkgname)

	fmt.Fprintf(&buf, `
	var DemuxReq2ObjAPIFnMap = [...]func(
	me interface{}, hd %[1]s_packet.Header, robj interface{}) (
	%[1]s_packet.Header, interface{}, error){
	`, prefix)
	for _, f := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s: Req2ObjAPI_%[2]s,\n", prefix, f[0])
	}
	fmt.Fprintf(&buf, "\n}   // DemuxReq2ObjAPIFnMap\n")

	for _, f := range cmddata {
		fmt.Fprintf(&buf, `
	func Req2ObjAPI_%[2]s(
		me interface{}, hd %[1]s_packet.Header, robj interface{}) (
		%[1]s_packet.Header, interface{},  error) {
		req, ok := robj.(*%[1]s_obj.Req%[2]s_data)
		if !ok {
			return hd, nil, fmt.Errorf("Packet type miss match %%v", robj)
		}
		rhd, rsp, err := objAPIFn_Req%[2]s(me, hd, req)
		return rhd, rsp, err
	}
	func objAPIFn_Req%[2]s(
		me interface{}, hd %[1]s_packet.Header, robj *%[1]s_obj.Req%[2]s_data) (
		%[1]s_packet.Header, *%[1]s_obj.Rsp%[2]s_data, error) {
		sendHeader := %[1]s_packet.Header{
			ErrorCode : %[1]s_error.None,
		}
		sendBody := &%[1]s_obj.Rsp%[2]s_data{
		}
		return sendHeader, sendBody, nil
	}
		`, prefix, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildRecvReqFnBytesAPITemplate(prefix string, pkgname string, cmddata, notidata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	/* bytes base fn map api template , unmarshal in api
	`, pkgname)

	fmt.Fprintf(&buf, `
	var DemuxReq2BytesAPIFnMap = [...]func(
	me interface{}, hd %[1]s_packet.Header, rbody []byte) (
	%[1]s_packet.Header, interface{}, error){
	`, prefix)
	for _, f := range cmddata {
		fmt.Fprintf(&buf, "%[1]s_idcmd.%[2]s: bytesAPIFn_Req%[2]s,\n", prefix, f[0])
	}
	fmt.Fprintf(&buf, "\n}   // DemuxReq2BytesAPIFnMap\n")

	for _, f := range cmddata {
		fmt.Fprintf(&buf, `
	func bytesAPIFn_Req%[2]s(
		me interface{}, hd %[1]s_packet.Header, rbody []byte) (
		%[1]s_packet.Header, interface{}, error) {
		// robj, err := %[1]s_json.UnmarshalPacket(hd, rbody)
		// if err != nil {
		// 	return hd, nil, fmt.Errorf("Packet type miss match %%v", rbody)
		// }
		// recvBody, ok := robj.(*%[1]s_obj.Req%[2]s_data)
		// if !ok {
		// 	return hd, nil, fmt.Errorf("Packet type miss match %%v", robj)
		// }
		// _ = recvBody
		
		sendHeader := %[1]s_packet.Header{
			ErrorCode : %[1]s_error.None,
		}
		sendBody := &%[1]s_obj.Rsp%[2]s_data{
		}
		return sendHeader, sendBody, nil
	}
		`, prefix, f[0])
	}
	fmt.Fprintf(&buf, `
	*/`)
	return &buf, nil
}

func buildConnTCP(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"context"
		"fmt"
		"net"
		"sync"
		"time"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	type Connection struct {
		conn         *net.TCPConn
		sendCh       chan %[1]s_packet.Packet
		sendRecvStop func()
	
		readTimeoutSec     time.Duration
		writeTimeoutSec    time.Duration
		marshalBodyFn      func(interface{}, []byte) ([]byte, byte, error)
		handleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error
		handleSentPacketFn func(header %[1]s_packet.Header) error
	}
	
	func New(
		readTimeoutSec, writeTimeoutSec time.Duration,
		marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
		handleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error,
		handleSentPacketFn func(header %[1]s_packet.Header) error,
	) *Connection {
		tc := &Connection{
			sendCh:             make(chan %[1]s_packet.Packet, 10),
			readTimeoutSec:     readTimeoutSec,
			writeTimeoutSec:    writeTimeoutSec,
			marshalBodyFn:      marshalBodyFn,
			handleRecvPacketFn: handleRecvPacketFn,
			handleSentPacketFn: handleSentPacketFn,
		}
	
		tc.sendRecvStop = func() {
			fmt.Printf("Too early sendRecvStop call %%v\n", tc)
		}
		return tc
	}
	
	func (tc *Connection) ConnectTo(remoteAddr string) error {
		tcpaddr, err := net.ResolveTCPAddr("tcp", remoteAddr)
		if err != nil {
			return err
		}
		tc.conn, err = net.DialTCP("tcp", nil, tcpaddr)
		if err != nil {
			return err
		}
		return nil
	}
	
	func (tc *Connection) Cleanup() {
		tc.sendRecvStop()
		if tc.conn != nil {
			tc.conn.Close()
		}
	}
	
	func (tc *Connection) Run(mainctx context.Context) error {
		sendRecvCtx, sendRecvCancel := context.WithCancel(mainctx)
		tc.sendRecvStop = sendRecvCancel
		var rtnerr error
		var sendRecvWaitGroup sync.WaitGroup
		sendRecvWaitGroup.Add(2)
		go func() {
			defer sendRecvWaitGroup.Done()
			err := %[1]s_looptcp.RecvLoop(
				sendRecvCtx,
				tc.sendRecvStop,
				tc.conn,
				tc.readTimeoutSec,
				tc.handleRecvPacketFn)
			if err != nil {
				rtnerr = err
			}
		}()
		go func() {
			defer sendRecvWaitGroup.Done()
			err := %[1]s_looptcp.SendLoop(
				sendRecvCtx,
				tc.sendRecvStop,
				tc.conn,
				tc.writeTimeoutSec,
				tc.sendCh,
				tc.marshalBodyFn,
				tc.handleSentPacketFn)
			if err != nil {
				rtnerr = err
			}
		}()
		sendRecvWaitGroup.Wait()
		return rtnerr
	}
	
	func (tc *Connection) EnqueueSendPacket(pk %[1]s_packet.Packet) error {
		trycount := 10
		for trycount > 0 {
			select {
			case tc.sendCh <- pk:
				return nil
			default:
				trycount--
			}
			time.Sleep(1 * time.Millisecond)
		}
		return fmt.Errorf("Send channel full %%v", tc)
	}
	`, prefix)
	return &buf, nil
}

func buildConnWasm(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"context"
		"fmt"
		"sync"
		"syscall/js"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	var bufPool = %[1]s_packet.NewPool(100)

	type Connection struct {
		remoteAddr   string
		conn         js.Value
		SendRecvStop func()
		sendCh       chan %[1]s_packet.Packet
	
		marshalBodyFn      func(interface{}, []byte) ([]byte, byte, error)
		handleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error
		handleSentPacketFn func(header %[1]s_packet.Header) error
	}
	
	func (wsc *Connection) String() string {
		return fmt.Sprintf("Connection[%%v SendCh:%%v]",
			wsc.remoteAddr, len(wsc.sendCh))
	}
	
	func New(
		connAddr string,
		marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
		handleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error,
		handleSentPacketFn func(header %[1]s_packet.Header) error,
	) *Connection {
		wsc := &Connection{
			remoteAddr:         connAddr,
			sendCh:             make(chan %[1]s_packet.Packet, 10),
			marshalBodyFn:      marshalBodyFn,
			handleRecvPacketFn: handleRecvPacketFn,
			handleSentPacketFn: handleSentPacketFn,
		}
		wsc.SendRecvStop = func() {
			JsLogErrorf("Too early SendRecvStop call %%v", wsc)
		}
		return wsc
	}
	
	func (wsc *Connection) Connect(ctx context.Context, wg *sync.WaitGroup) error {
		connCtx, ctxCancel := context.WithCancel(ctx)
		wsc.SendRecvStop = ctxCancel
	
		wsc.conn = js.Global().Get("WebSocket").New(wsc.remoteAddr)
		if !wsc.conn.Truthy() {
			err := fmt.Errorf("fail to connect %%v", wsc.remoteAddr)
			JsLogErrorf("%%v", err)
			return err
		}
		wsc.conn.Call("addEventListener", "open", js.FuncOf(
			func(this js.Value, args []js.Value) interface{} {
				wsc.conn.Call("addEventListener", "message", js.FuncOf(wsc.handleWebsocketMessage))
				go wsc.sendLoop(connCtx)
				wg.Done()
				return nil
			}))
		wsc.conn.Call("addEventListener", "close", js.FuncOf(wsc.wsClosed))
		wsc.conn.Call("addEventListener", "error", js.FuncOf(wsc.wsError))
		return nil
	}
	
	func (wsc *Connection) wsClosed(this js.Value, args []js.Value) interface{} {
		wsc.SendRecvStop()
		JsLogError("ws closed")
		return nil
	}
	
	func (wsc *Connection) wsError(this js.Value, args []js.Value) interface{} {
		wsc.SendRecvStop()
		JsLogError(this, args)
		return nil
	}
	
	func (wsc *Connection) sendLoop(sendRecvCtx context.Context) {
		defer wsc.SendRecvStop()
		var err error
	loop:
		for {
			select {
			case <-sendRecvCtx.Done():
				break loop
			case pk := <-wsc.sendCh:
				oldbuf := bufPool.Get()
				sendBuffer, err := %[1]s_packet.Packet2Bytes(&pk, wsc.marshalBodyFn, oldbuf)
				if err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				if err = wsc.sendPacket(sendBuffer); err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				if err = wsc.handleSentPacketFn(pk.Header); err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				bufPool.Put(oldbuf)
			}
		}
		JsLogErrorf("end SendLoop %v\n", err)
		return
	}
		
	func (wsc *Connection) sendPacket(sendBuffer []byte) error {
		sendData := js.Global().Get("Uint8Array").New(len(sendBuffer))
		js.CopyBytesToJS(sendData, sendBuffer)
		wsc.conn.Call("send", sendData)
		return nil
	}
	
	func (wsc *Connection) handleWebsocketMessage(this js.Value, args []js.Value) interface{} {
		data := args[0].Get("data") // blob
		aBuff := data.Call("arrayBuffer")
		aBuff.Call("then",
			js.FuncOf(func(this js.Value, args []js.Value) interface{} {
	
				rdata := ArrayBufferToSlice(args[0])
				rPk := %[1]s_packet.NewRecvPacketBufferByData(rdata)
				header, body, lerr := rPk.GetHeaderBody()
				if lerr != nil {
					JsLogError(lerr.Error())
					wsc.SendRecvStop()
					return nil
				} else {
					if err := wsc.handleRecvPacketFn(header, body); err != nil {
						JsLogErrorf("%%v", err)
						wsc.SendRecvStop()
						return nil
					}
				}
				return nil
			}))
	
		return nil
	}
	
	func Uint8ArrayToSlice(value js.Value) []byte {
		s := make([]byte, value.Get("byteLength").Int())
		js.CopyBytesToGo(s, value)
		return s
	}
	
	func ArrayBufferToSlice(value js.Value) []byte {
		return Uint8ArrayToSlice(js.Global().Get("Uint8Array").New(value))
	}
	
	func (wsc *Connection) EnqueueSendPacket(pk %[1]s_packet.Packet) error {
		select {
		case wsc.sendCh <- pk:
			return nil
		default:
			return fmt.Errorf("Send channel full %%v", wsc)
		}
	}
	
	/////////
	
	func JsLogError(v ...interface{}) {
		js.Global().Get("console").Call("error", v...)
	}
	
	func JsLogErrorf(format string, v ...interface{}) {
		js.Global().Get("console").Call("error", fmt.Sprintf(format, v...))
	}
		`, prefix)
	return &buf, nil
}

func buildConnWSGorilla(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"context"
		"fmt"
		"net/url"
		"sync"
		"time"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	type Connection struct {
		wsConn       *websocket.Conn
		sendRecvStop func()
		sendCh       chan %[1]s_packet.Packet
	
		readTimeoutSec     time.Duration
		writeTimeoutSec    time.Duration
		marshalBodyFn      func(interface{}, []byte) ([]byte, byte, error)
		handleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error
		handleSentPacketFn func(header %[1]s_packet.Header) error
	}
	
	func New(
		readTimeoutSec, writeTimeoutSec time.Duration,
		marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
		handleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error,
		handleSentPacketFn func(header %[1]s_packet.Header) error,
	) *Connection {
		tc := &Connection{
			sendCh:             make(chan %[1]s_packet.Packet, 10),
			readTimeoutSec:     readTimeoutSec,
			writeTimeoutSec:    writeTimeoutSec,
			marshalBodyFn:      marshalBodyFn,
			handleRecvPacketFn: handleRecvPacketFn,
			handleSentPacketFn: handleSentPacketFn,
		}
	
		tc.sendRecvStop = func() {
			fmt.Printf("Too early sendRecvStop call")
		}
		return tc
	}
	
	func (tc *Connection) ConnectTo(connAddr string) error {
		u := url.URL{Scheme: "ws", Host: connAddr, Path: "/ws"}
		var err error
		tc.wsConn, _, err = websocket.DefaultDialer.Dial(u.String(), nil)
		if err != nil {
			return err
		}
		return nil
	}
	
	func (tc *Connection) Cleanup() {
		tc.sendRecvStop()
		if tc.wsConn != nil {
			tc.wsConn.Close()
		}
	}
	
	func (tc *Connection) Run(aictx context.Context) error {
		connCtx, ctxCancel := context.WithCancel(aictx)
		tc.sendRecvStop = ctxCancel
		var rtnerr error
		var sendRecvWaitGroup sync.WaitGroup
		sendRecvWaitGroup.Add(2)
		go func() {
			defer sendRecvWaitGroup.Done()
			err := %[1]s_loopwsgorilla.RecvLoop(
				connCtx,
				tc.sendRecvStop,
				tc.wsConn,
				tc.readTimeoutSec,
				tc.handleRecvPacketFn,
			)
			if err != nil {
				rtnerr = err
			}
		}()
		go func() {
			defer sendRecvWaitGroup.Done()
			err := %[1]s_loopwsgorilla.SendLoop(
				connCtx,
				tc.sendRecvStop,
				tc.wsConn,
				tc.writeTimeoutSec,
				tc.sendCh,
				tc.marshalBodyFn,
				tc.handleSentPacketFn,
			)
			if err != nil {
				rtnerr = err
			}
		}()
		sendRecvWaitGroup.Wait()
		return rtnerr
	}
	
	func (tc *Connection) EnqueueSendPacket(pk %[1]s_packet.Packet) error {
		trycount := 10
		for trycount > 0 {
			select {
			case tc.sendCh <- pk:
				return nil
			default:
				trycount--
			}
			time.Sleep(1 * time.Millisecond)
		}
	
		return fmt.Errorf("Send channel full %%v", tc)
	}
	`, prefix)
	return &buf, nil
}

func buildLoopWSGorilla(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"context"
		"fmt"
		"net"
		"time"
		"github.com/gorilla/websocket"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `

	var bufPool = %[1]s_packet.NewPool(100)

	func SendControl(
		wsConn *websocket.Conn, mt int, PacketWriteTimeOut time.Duration) error {
	
		return wsConn.WriteControl(mt, []byte{}, time.Now().Add(PacketWriteTimeOut))
	}
	
	func SendPacket(wsConn *websocket.Conn, sendBuffer []byte) error {
		return wsConn.WriteMessage(websocket.BinaryMessage, sendBuffer)
	}
	
	func SendLoop(sendRecvCtx context.Context, SendRecvStop func(), wsConn *websocket.Conn,
		timeout time.Duration,
		SendCh chan %[1]s_packet.Packet,
		marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
		handleSentPacketFn func(header %[1]s_packet.Header) error,
	) error {

		defer SendRecvStop()
		var err error
	loop:
		for {
			select {
			case <-sendRecvCtx.Done():
				err = SendControl(wsConn, websocket.CloseMessage, timeout)
				break loop
			case pk := <-SendCh:
				if err = wsConn.SetWriteDeadline(time.Now().Add(timeout)); err != nil {
					break loop
				}
				oldbuf := bufPool.Get()
				sendBuffer, err := %[1]s_packet.Packet2Bytes(&pk, marshalBodyFn, oldbuf)
				if err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				if err = SendPacket(wsConn, sendBuffer); err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				if err = handleSentPacketFn(pk.Header); err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				bufPool.Put(oldbuf)
			}
		}
		return err
	}
	
	func RecvLoop(sendRecvCtx context.Context, SendRecvStop func(), wsConn *websocket.Conn,
		timeout time.Duration,
		HandleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error) error {
	
		defer SendRecvStop()
		var err error
	loop:
		for {
			select {
			case <-sendRecvCtx.Done():
				break loop
			default:
				if err = wsConn.SetReadDeadline(time.Now().Add(timeout)); err != nil {
					break loop
				}
				if header, body, lerr := RecvPacket(wsConn); lerr != nil {
					if operr, ok := lerr.(*net.OpError); ok && operr.Timeout() {
						continue
					}
					err = lerr
					break loop
				} else {
					if err = HandleRecvPacketFn(header, body); err != nil {
						break loop
					}
				}
			}
		}
		return err
	}
	
	func RecvPacket(wsConn *websocket.Conn) (%[1]s_packet.Header, []byte, error) {
		mt, rdata, err := wsConn.ReadMessage()
		if err != nil {
			return %[1]s_packet.Header{}, nil, err
		}
		if mt != websocket.BinaryMessage {
			return %[1]s_packet.Header{}, nil, fmt.Errorf("message not binary %%v", mt)
		}
		return %[1]s_packet.NewRecvPacketBufferByData(rdata).GetHeaderBody()
	}
	`, prefix)
	return &buf, nil
}

func buildLoopTCP(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"context"
		"net"
		"time"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	var bufPool = c2t_packet.NewPool(100)

	func SendPacket(conn *net.TCPConn, buf []byte) error {
		toWrite := len(buf)
		for l := 0; l < toWrite; {
			n, err := conn.Write(buf[l:toWrite])
			if err != nil {
				return err
			}
			l += n
		}
		return nil
	}
	
	func SendLoop(sendRecvCtx context.Context, SendRecvStop func(), tcpConn *net.TCPConn,
		timeOut time.Duration,
		SendCh chan %[1]s_packet.Packet,
		marshalBodyFn func(interface{}, []byte) ([]byte, byte, error),
		handleSentPacketFn func(header %[1]s_packet.Header) error,
	) error {

		defer SendRecvStop()
		var err error
	loop:
		for {
			select {
			case <-sendRecvCtx.Done():
				break loop
			case pk := <-SendCh:
				if err = tcpConn.SetWriteDeadline(time.Now().Add(timeOut)); err != nil {
					break loop
				}
				oldbuf := bufPool.Get()
				sendBuffer, err := %[1]s_packet.Packet2Bytes(&pk, marshalBodyFn, oldbuf)
				if err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				if err = SendPacket(tcpConn, sendBuffer); err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				if err = handleSentPacketFn(pk.Header); err != nil {
					bufPool.Put(oldbuf)
					break loop
				}
				bufPool.Put(oldbuf)
			}
		}
		return err
	}
	
	func RecvLoop(sendRecvCtx context.Context, SendRecvStop func(), tcpConn *net.TCPConn,
		timeOut time.Duration,
		HandleRecvPacketFn func(header %[1]s_packet.Header, body []byte) error,
	) error {
	
		defer SendRecvStop()
	
		pb := %[1]s_packet.NewRecvPacketBuffer()
		var err error
	loop:
		for {
			select {
			case <-sendRecvCtx.Done():
				return nil
	
			default:
				if pb.IsPacketComplete() {
					header, rbody, lerr := pb.GetHeaderBody()
					if lerr != nil {
						err = lerr
						break loop
					}
					if err = HandleRecvPacketFn(header, rbody); err != nil {
						break loop
					}
					pb = %[1]s_packet.NewRecvPacketBuffer()
					if err = tcpConn.SetReadDeadline(time.Now().Add(timeOut)); err != nil {
						break loop
					}
				} else {
					err := pb.Read(tcpConn)
					if err != nil {
						return err
					}
				}
			}
		}
		return err
	}
	`, prefix)
	return &buf, nil
}

func buildStatNoti(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"fmt"
		"net/http"
		"sync"
		"text/template"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	func (ns *StatNotification) String() string {
		return fmt.Sprintf("StatNotification[%%v]", len(ns))
	}
	type StatNotification [%[1]s_idnoti.NotiID_Count]StatRow
	func New() *StatNotification {
		ns := new(StatNotification)
		for i := 0; i < %[1]s_idnoti.NotiID_Count; i++ {
			ns[i].Name = %[1]s_idnoti.NotiID(i).String()
		}
		return ns
	}
	func (ns *StatNotification) Add(hd %[1]s_packet.Header) {
		if int(hd.Cmd) >= %[1]s_idnoti.NotiID_Count {
			return
		}
		ns[hd.Cmd].add(hd)
	}
	func (ns *StatNotification) ToWeb(w http.ResponseWriter, r *http.Request) error {
		tplIndex, err := template.New("index").Parse(%[2]c
	<html><head><title>Notification packet stat Info</title></head><body>
	<table border=1 style="border-collapse:collapse;">%[2]c +
			HTML_tableheader +
			%[2]c{{range $i, $v := .}}%[2]c +
			HTML_row +
			%[2]c{{end}}%[2]c +
			HTML_tableheader +
			%[2]c</table><br/>
	</body></html>%[2]c)
		if err != nil {
			return err
		}
		if err := tplIndex.Execute(w, ns); err != nil {
			return err
		}
		return nil
	}
	const (
		HTML_tableheader = %[2]c<tr>
	<th>Name</th>
	<th>Count</th>
	<th>Total Byte</th>
	<th>Max Byte</th>
	<th>Avg Byte</th>
	</tr>%[2]c
		HTML_row = %[2]c<tr>
	<td>{{$v.Name}}</td>
	<td>{{$v.Count }}</td>
	<td>{{$v.TotalByte }}</td>
	<td>{{$v.MaxByte }}</td>
	<td>{{printf "%%10.3f" $v.Avg }}</td>
	</tr>
	%[2]c
	)
	type StatRow struct {
		mutex     sync.Mutex
		Name      string
		Count     int
		TotalByte int
		MaxByte   int
	}
	func (ps *StatRow) add(hd %[1]s_packet.Header) {
		ps.mutex.Lock()
		ps.Count++
		n := int(hd.BodyLen()) + %[1]s_packet.HeaderLen
		ps.TotalByte += n
		if n > ps.MaxByte {
			ps.MaxByte = n
		}
		ps.mutex.Unlock()
	}
		func (ps *StatRow) Avg() float64 {
		return float64(ps.TotalByte) / float64(ps.Count)
	}
	`, prefix, '`')
	return &buf, nil
}

func buildStatCallAPI(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"fmt"
		"html/template"
		"net/http"
		"sync"
		"time"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	func (cps *StatCallAPI) String() string {
		return fmt.Sprintf("StatCallAPI[%%v]",
			len(cps))
	}
	type StatCallAPI [%[1]s_idcmd.CommandID_Count]StatRow
	func New() *StatCallAPI {
		cps := new(StatCallAPI)
		for i := 0; i < %[1]s_idcmd.CommandID_Count; i++ {
			cps[i].Name = %[1]s_idcmd.CommandID(i).String()
		}
		return cps
	}
	func (cps *StatCallAPI) BeforeSendReq(header %[1]s_packet.Header) (*statObj, error) {
		if int(header.Cmd) >= %[1]s_idcmd.CommandID_Count {
			return nil, fmt.Errorf("CommandID out of range %%v %%v",
				header, %[1]s_idcmd.CommandID_Count)
		}
		return cps[header.Cmd].open(), nil
	}
	func (cps *StatCallAPI) AfterSendReq(header %[1]s_packet.Header) error {
		if int(header.Cmd) >= %[1]s_idcmd.CommandID_Count {
			return fmt.Errorf("CommandID out of range %%v %%v", header, %[1]s_idcmd.CommandID_Count)
		}
		n := int(header.BodyLen()) + %[1]s_packet.HeaderLen
		cps[header.Cmd].addTx(n)
		return nil
	}
	func (cps *StatCallAPI) AfterRecvRsp(header %[1]s_packet.Header) error {
		if int(header.Cmd) >= %[1]s_idcmd.CommandID_Count {
			return fmt.Errorf("CommandID out of range %%v %%v", header, %[1]s_idcmd.CommandID_Count)
		}
		n := int(header.BodyLen()) + %[1]s_packet.HeaderLen
		cps[header.Cmd].addRx(n)
		return nil
	}
	func (ws *StatCallAPI) ToWeb(w http.ResponseWriter, r *http.Request) error {
		tplIndex, err := template.New("index").Parse(%[2]c
	<html><head><title>Call API Stat Info</title></head><body>
	<table border=1 style="border-collapse:collapse;">%[2]c +
			HTML_tableheader +
			%[2]c{{range $i, $v := .}}%[2]c +
			HTML_row +
			%[2]c{{end}}%[2]c +
			HTML_tableheader +
			%[2]c</table><br/>
	</body></html>%[2]c)
		if err != nil {
			return err
		}
		if err := tplIndex.Execute(w, ws); err != nil {
			return err
		}
		return nil
	}
	////////////////////////////////////////////////////////////////////////////////
	type statObj struct {
		StartTime time.Time
		StatRef   *StatRow
	}
	func (so *statObj) CallServerEnd(success bool) {
		so.StatRef.close(success, so.StartTime)
	}
	////////////////////////////////////////////////////////////////////////////////
	type PacketID2StatObj struct {
		mutex sync.RWMutex
		stats map[uint32]*statObj
	}
	func NewPacketID2StatObj() *PacketID2StatObj {
		return &PacketID2StatObj{
			stats: make(map[uint32]*statObj),
		}
	}
	func (som *PacketID2StatObj) Add(pkid uint32, so *statObj) error {
		som.mutex.Lock()
		defer som.mutex.Unlock()
		if _, exist := som.stats[pkid]; exist {
			return fmt.Errorf("pkid exist %v", pkid)
		}
		som.stats[pkid] = so
		return nil
	}
	func (som *PacketID2StatObj) Del(pkid uint32) *statObj {
		som.mutex.Lock()
		defer som.mutex.Unlock()
		so := som.stats[pkid]
		delete(som.stats, pkid)
		return so
	}
	func (som *PacketID2StatObj) Get(pkid uint32) *statObj {
		som.mutex.RLock()
		defer som.mutex.RUnlock()
		return som.stats[pkid]
	}
	////////////////////////////////////////////////////////////////////////////////
	const (
		HTML_tableheader = %[2]c<tr>
	<th>Name</th>
	<th>Start</th>
	<th>End</th>
	<th>Success</th>
	<th>Running</th>
	<th>Fail</th>
	<th>Avg ms</th>
	<th>TxAvg Byte</th>
	<th>RxAvg Byte</th>
	</tr>%[2]c
		HTML_row = %[2]c<tr>
	<td>{{$v.Name}}</td>
	<td>{{$v.StartCount}}</td>
	<td>{{$v.EndCount}}</td>
	<td>{{$v.SuccessCount}}</td>
	<td>{{$v.RunCount}}</td>
	<td>{{$v.FailCount}}</td>
	<td>{{printf "%%13.6f" $v.Avgms }}</td>
	<td>{{printf "%%10.3f" $v.AvgTx }}</td>
	<td>{{printf "%%10.3f" $v.AvgRx }}</td>
	</tr>
	%[2]c
	)
	type StatRow struct {
		mutex sync.Mutex
		Name  string
		TxCount int
		TxByte  int
		RxCount int
		RxByte  int
		StartCount   int
		EndCount     int
		SuccessCount int
		Sum          time.Duration
	}
	func (sr *StatRow) open() *statObj {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.StartCount++
		return &statObj{
			StartTime: time.Now(),
			StatRef:   sr,
		}
	}
	func (sr *StatRow) close(success bool, startTime time.Time) {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.EndCount++
		if success {
			sr.SuccessCount++
			sr.Sum += time.Now().Sub(startTime)
		}
	}
	func (sr *StatRow) addTx(n int) {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.TxCount++
		sr.TxByte += n
	}
	func (sr *StatRow) addRx(n int) {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.RxCount++
		sr.RxByte += n
	}
	func (sr *StatRow) RunCount() int {
		return sr.StartCount - sr.EndCount
	}
	func (sr *StatRow) FailCount() int {
		return sr.EndCount - sr.SuccessCount
	}
	func (sr *StatRow) Avgms() float64 {
		if sr.EndCount != 0 {
			return float64(sr.Sum) / float64(sr.EndCount*1000000)
		}
		return 0.0
	}
	func (sr *StatRow) AvgRx() float64 {
		if sr.EndCount != 0 {
			return float64(sr.RxByte) / float64(sr.RxCount)
		}
		return 0.0
	}
	func (sr *StatRow) AvgTx() float64 {
		if sr.EndCount != 0 {
			return float64(sr.TxByte) / float64(sr.TxCount)
		}
		return 0.0
	}
	`, prefix, '`')
	return &buf, nil
}

func buildStatServeAPI(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"fmt"
		"net/http"
		"sync"
		"text/template"
		"time"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	func (ps *StatServeAPI) String() string {
		return fmt.Sprintf("StatServeAPI[%%v]", len(ps))
	}
	type StatServeAPI [%[1]s_idcmd.CommandID_Count]StatRow
	func New() *StatServeAPI {
		ps := new(StatServeAPI)
		for i := 0; i < %[1]s_idcmd.CommandID_Count; i++ {
			ps[i].Name = %[1]s_idcmd.CommandID(i).String()
		}
		return ps
	}
	func (ps *StatServeAPI) AfterRecvReqHeader(header %[1]s_packet.Header) (*StatObj, error) {
		if int(header.Cmd) >= %[1]s_idcmd.CommandID_Count {
			return nil, fmt.Errorf("CommandID out of range %%v %%v", header, %[1]s_idcmd.CommandID_Count)
		}
		return ps[header.Cmd].open(header), nil
	}
	func (ws *StatServeAPI) ToWeb(w http.ResponseWriter, r *http.Request) error {
		tplIndex, err := template.New("index").Parse(%[2]c
	<html><head><title>Serve API stat Info</title></head><body>
	<table border=1 style="border-collapse:collapse;">%[2]c +
			HTML_tableheader +
			%[2]c{{range $i, $v := .}}%[2]c +
			HTML_row +
			%[2]c{{end}}%[2]c +
			HTML_tableheader +
			%[2]c</table><br/>
	</body></html>%[2]c)
		if err != nil {
			return err
		}
		if err := tplIndex.Execute(w, ws); err != nil {
			return err
		}
		return nil
	}
	////////////////////////////////////////////////////////////////////////////////
	type StatObj struct {
		RecvTime    time.Time
		APICallTime time.Time
		StatRef     *StatRow
	}
	func (sm *StatObj) BeforeAPICall() {
		sm.APICallTime = time.Now().UTC()
		sm.StatRef.afterAuth()
	}
	func (sm *StatObj) AfterAPICall() {
		sm.StatRef.apiEnd(time.Now().UTC().Sub(sm.APICallTime))
	}
	func (sm *StatObj) AfterSendRsp(hd %[1]s_packet.Header) {
		sm.StatRef.afterSend(time.Now().UTC().Sub(sm.RecvTime), hd)
	}
	////////////////////////////////////////////////////////////////////////////////
	type PacketID2StatObj struct {
		mutex sync.RWMutex
		stats map[uint32]*StatObj
	}
	func NewPacketID2StatObj() *PacketID2StatObj {
		return &PacketID2StatObj{
			stats: make(map[uint32]*StatObj),
		}
	}
	func (som *PacketID2StatObj) Add(pkid uint32, so *StatObj) error {
		som.mutex.Lock()
		defer som.mutex.Unlock()
		if _, exist := som.stats[pkid]; exist {
			return fmt.Errorf("pkid exist %%v", pkid)
		}
		som.stats[pkid] = so
		return nil
	}
	func (som *PacketID2StatObj) Del(pkid uint32) *StatObj {
		som.mutex.Lock()
		defer som.mutex.Unlock()
		so := som.stats[pkid]
		delete(som.stats, pkid)
		return so
	}
	func (som *PacketID2StatObj) Get(pkid uint32) *StatObj {
		som.mutex.RLock()
		defer som.mutex.RUnlock()
		return som.stats[pkid]
	}
	////////////////////////////////////////////////////////////////////////////////
	const (
		HTML_tableheader = %[2]c<tr>
	<th>Name</th>
	<th>Recv Count</th>
	<th>Auth Count</th>
	<th>APIEnd Count</th>
	<th>Send Count</th>
	<th>Run Count</th>
	<th>Fail Count</th>
	<th>RecvSend Avg ms</th>
	<th>API Avg ms</th>
	<th>Rx Avg Byte</th>
	<th>Rx Max Byte</th>
	<th>Tx Avg Byte</th>
	<th>Tx Max Byte</th>
	</tr>%[2]c
		HTML_row = %[2]c<tr>
	<td>{{$v.Name}}</td>
	<td>{{$v.RecvCount}}</td>
	<td>{{$v.AuthCount}}</td>
	<td>{{$v.APIEndCount}}</td>
	<td>{{$v.SendCount}}</td>
	<td>{{$v.RunCount}}</td>
	<td>{{$v.FailCount}}</td>
	<td>{{printf "%%13.6f" $v.RSAvgms }}</td>
	<td>{{printf "%%13.6f" $v.APIAvgms }}</td>
	<td>{{printf "%%10.3f" $v.AvgRxByte }}</td>
	<td>{{$v.MaxRecvBytes }}</td>
	<td>{{printf "%%10.3f" $v.AvgTxByte }}</td>
	<td>{{$v.MaxSendBytes }}</td>
	</tr>
	%[2]c
	)
	type StatRow struct {
		mutex sync.Mutex
		Name  string
		RecvCount    int
		MaxRecvBytes int
		RecvBytes    int
		SendCount    int
		MaxSendBytes int
		SendBytes    int
		RecvSendDurSum time.Duration
		AuthCount      int
		APIEndCount    int
		APIDurSum      time.Duration
	}
	func (sr *StatRow) open(hd %[1]s_packet.Header) *StatObj {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.RecvCount++
		rxbyte := int(hd.BodyLen()) + %[1]s_packet.HeaderLen
		sr.RecvBytes += rxbyte
		if sr.MaxRecvBytes < rxbyte {
			sr.MaxRecvBytes = rxbyte
		}
		rtn := &StatObj{
			RecvTime: time.Now().UTC(),
			StatRef:  sr,
		}
		return rtn
	}
		func (sr *StatRow) afterAuth() {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.AuthCount++
	}
	func (sr *StatRow) apiEnd(diffDur time.Duration) {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.APIEndCount++
		sr.APIDurSum += diffDur
	}
	func (sr *StatRow) afterSend(diffDur time.Duration, hd %[1]s_packet.Header) {
		sr.mutex.Lock()
		defer sr.mutex.Unlock()
		sr.SendCount++
		txbyte := int(hd.BodyLen()) + %[1]s_packet.HeaderLen
		sr.SendBytes += txbyte
		if sr.MaxSendBytes < txbyte {
			sr.MaxSendBytes = txbyte
		}
		sr.RecvSendDurSum += diffDur
	}
		////////////////////////////////////////////////////////////////////////////////
	func (sr *StatRow) RunCount() int {
		return sr.AuthCount - sr.APIEndCount
	}
	func (sr *StatRow) FailCount() int {
		return sr.APIEndCount - sr.SendCount
	}
	func (sr *StatRow) RSAvgms() float64 {
		if sr.SendCount == 0 {
			return 0
		}
		return float64(sr.RecvSendDurSum) / float64(sr.SendCount*1000000)
	}
	func (sr *StatRow) APIAvgms() float64 {
		if sr.APIEndCount == 0 {
			return 0
		}
		return float64(sr.APIDurSum) / float64(sr.APIEndCount*1000000)
	}
	func (sr *StatRow) AvgRxByte() float64 {
		if sr.RecvCount == 0 {
			return 0
		}
		return float64(sr.RecvBytes) / float64(sr.RecvCount)
	}
	func (sr *StatRow) AvgTxByte() float64 {
		if sr.SendCount == 0 {
			return 0
		}
		return float64(sr.SendBytes) / float64(sr.SendCount)
	}
	`, prefix, '`')
	return &buf, nil
}

func buildStatAPIError(prefix string, pkgname string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s
	import (
		"fmt"
		"html/template"
		"net/http"
		"sync"
	)
	`, pkgname)
	fmt.Fprintf(&buf, `
	func (es *StatAPIError) String() string {
		return fmt.Sprintf(
			"StatAPIError[%%v %%v %%v]",
			len(es.Stat),
			len(es.ECList),
			len(es.CmdList),
		)
	}
	type StatAPIError struct {
		mutex   sync.RWMutex
		Stat    [][]int
		ECList  []string
		CmdList []string
	}
	func New() *StatAPIError {
		es := &StatAPIError{
			Stat: make([][]int, %[1]s_idcmd.CommandID_Count),
		}
		for i, _ := range es.Stat {
			es.Stat[i] = make([]int, %[1]s_error.ErrorCode_Count)
		}
		es.ECList = make([]string, %[1]s_error.ErrorCode_Count)
		for i, _ := range es.ECList {
			es.ECList[i] = fmt.Sprintf("%%s", %[1]s_error.ErrorCode(i).String())
		}
		es.CmdList = make([]string, %[1]s_idcmd.CommandID_Count)
		for i, _ := range es.CmdList {
			es.CmdList[i] = fmt.Sprintf("%%v", %[1]s_idcmd.CommandID(i))
		}
		return es
	}
	func (es *StatAPIError) Inc(cmd %[1]s_idcmd.CommandID, errorcode %[1]s_error.ErrorCode) {
		es.mutex.Lock()
		defer es.mutex.Unlock()
		es.Stat[cmd][errorcode]++
	}
	func (es *StatAPIError) ToWeb(w http.ResponseWriter, r *http.Request) error {
		tplIndex, err := template.New("index").Parse(%[2]c
	<html><head><title>API Error stat Info</title></head><body>
	<table border=1 style="border-collapse:collapse;">
	<tr>
		<td></td>
		{{range $ft, $v := .ECList}}
			<th>{{$v}}</th>
		{{end}}
	</tr>
	{{range $cmd, $w := .Stat}}
		<tr>
			<td>{{index $.CmdList $cmd}}</td>
			{{range $ft, $v := $w}}
				<td>{{$v}}</td>
			{{end}}
		</tr>
	{{end}}
	<tr>
		<td></td>
		{{range $ft, $v := .ECList}}
			<th>{{$v}}</th>
		{{end}}
	</tr>
	</table><br/>
	</body></html>%[2]c)
		if err != nil {
			return err
		}
		if err := tplIndex.Execute(w, es); err != nil {
			return err
		}
		return nil
	}
	`, prefix, '`')
	return &buf, nil
}
