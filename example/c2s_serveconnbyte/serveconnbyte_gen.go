// Code generated by "genprotocol.exe -ver=1.0 -prefix=c2s -basedir=example -statstype=int"

package c2s_serveconnbyte

import (
	"context"
	"fmt"
	"net"
	"time"

	"github.com/gorilla/websocket"
	"github.com/kasworld/genprotocol/example/c2s_authorize"
	"github.com/kasworld/genprotocol/example/c2s_const"
	"github.com/kasworld/genprotocol/example/c2s_idcmd"
	"github.com/kasworld/genprotocol/example/c2s_idnoti"
	"github.com/kasworld/genprotocol/example/c2s_looptcp"
	"github.com/kasworld/genprotocol/example/c2s_loopwsgorilla"
	"github.com/kasworld/genprotocol/example/c2s_packet"
	"github.com/kasworld/genprotocol/example/c2s_statapierror"
	"github.com/kasworld/genprotocol/example/c2s_statnoti"
	"github.com/kasworld/genprotocol/example/c2s_statserveapi"
)

type CounterI interface {
	Inc()
}

func (scb *ServeConnByte) String() string {
	return fmt.Sprintf("ServeConnByte[SendCh:%v/%v]",
		len(scb.sendCh), cap(scb.sendCh))
}

type ServeConnByte struct {
	connData       interface{} // custom data for this conn
	sendCh         chan *c2s_packet.Packet
	sendRecvStop   func()
	authorCmdList  *c2s_authorize.AuthorizedCmds
	pid2ApiStatObj *c2s_statserveapi.PacketID2StatObj
	apiStat        *c2s_statserveapi.StatServeAPI
	notiStat       *c2s_statnoti.StatNotification
	errorStat      *c2s_statapierror.StatAPIError
	sendCounter    CounterI
	recvCounter    CounterI

	demuxReq2BytesAPIFnMap [c2s_idcmd.CommandID_Count]func(
		me interface{}, hd c2s_packet.Header, rbody []byte) (
		c2s_packet.Header, interface{}, error)
}

// New with stats local
func New(
	connData interface{},
	sendBufferSize int,
	authorCmdList *c2s_authorize.AuthorizedCmds,
	sendCounter, recvCounter CounterI,
	demuxReq2BytesAPIFnMap [c2s_idcmd.CommandID_Count]func(
		me interface{}, hd c2s_packet.Header, rbody []byte) (
		c2s_packet.Header, interface{}, error),
) *ServeConnByte {
	scb := &ServeConnByte{
		connData:               connData,
		sendCh:                 make(chan *c2s_packet.Packet, sendBufferSize),
		pid2ApiStatObj:         c2s_statserveapi.NewPacketID2StatObj(),
		apiStat:                c2s_statserveapi.New(),
		notiStat:               c2s_statnoti.New(),
		errorStat:              c2s_statapierror.New(),
		sendCounter:            sendCounter,
		recvCounter:            recvCounter,
		authorCmdList:          authorCmdList,
		demuxReq2BytesAPIFnMap: demuxReq2BytesAPIFnMap,
	}
	scb.sendRecvStop = func() {
		fmt.Printf("Too early sendRecvStop call %v\n", scb)
	}
	return scb
}

// NewWithStats with stats global
func NewWithStats(
	connData interface{},
	sendBufferSize int,
	authorCmdList *c2s_authorize.AuthorizedCmds,
	sendCounter, recvCounter CounterI,
	apiStat *c2s_statserveapi.StatServeAPI,
	notiStat *c2s_statnoti.StatNotification,
	errorStat *c2s_statapierror.StatAPIError,
	demuxReq2BytesAPIFnMap [c2s_idcmd.CommandID_Count]func(
		me interface{}, hd c2s_packet.Header, rbody []byte) (
		c2s_packet.Header, interface{}, error),
) *ServeConnByte {
	scb := &ServeConnByte{
		connData:               connData,
		sendCh:                 make(chan *c2s_packet.Packet, sendBufferSize),
		pid2ApiStatObj:         c2s_statserveapi.NewPacketID2StatObj(),
		apiStat:                apiStat,
		notiStat:               notiStat,
		errorStat:              errorStat,
		sendCounter:            sendCounter,
		recvCounter:            recvCounter,
		authorCmdList:          authorCmdList,
		demuxReq2BytesAPIFnMap: demuxReq2BytesAPIFnMap,
	}
	scb.sendRecvStop = func() {
		fmt.Printf("Too early sendRecvStop call %v\n", scb)
	}
	return scb
}

func (scb *ServeConnByte) Disconnect() {
	scb.sendRecvStop()
}
func (scb *ServeConnByte) GetConnData() interface{} {
	return scb.connData
}
func (scb *ServeConnByte) GetAPIStat() *c2s_statserveapi.StatServeAPI {
	return scb.apiStat
}
func (scb *ServeConnByte) GetNotiStat() *c2s_statnoti.StatNotification {
	return scb.notiStat
}
func (scb *ServeConnByte) GetErrorStat() *c2s_statapierror.StatAPIError {
	return scb.errorStat
}
func (scb *ServeConnByte) GetAuthorCmdList() *c2s_authorize.AuthorizedCmds {
	return scb.authorCmdList
}
func (scb *ServeConnByte) StartServeWS(
	mainctx context.Context, conn *websocket.Conn,
	readTimeoutSec, writeTimeoutSec time.Duration,
	marshalfn func(body interface{}, oldBuffToAppend []byte) ([]byte, byte, error),
) error {
	var returnerr error
	sendRecvCtx, sendRecvCancel := context.WithCancel(mainctx)
	scb.sendRecvStop = sendRecvCancel
	go func() {
		err := c2s_loopwsgorilla.RecvLoop(sendRecvCtx, scb.sendRecvStop, conn,
			readTimeoutSec, scb.handleRecvPacket)
		if err != nil {
			returnerr = fmt.Errorf("end RecvLoop %v", err)
		}
	}()
	go func() {
		err := c2s_loopwsgorilla.SendLoop(sendRecvCtx, scb.sendRecvStop, conn,
			writeTimeoutSec, scb.sendCh,
			marshalfn, scb.handleSentPacket)
		if err != nil {
			returnerr = fmt.Errorf("end SendLoop %v", err)
		}
	}()
loop:
	for {
		select {
		case <-sendRecvCtx.Done():
			break loop
		}
	}
	return returnerr
}
func (scb *ServeConnByte) StartServeTCP(
	mainctx context.Context, conn *net.TCPConn,
	readTimeoutSec, writeTimeoutSec time.Duration,
	marshalfn func(body interface{}, oldBuffToAppend []byte) ([]byte, byte, error),
) error {
	var returnerr error
	sendRecvCtx, sendRecvCancel := context.WithCancel(mainctx)
	scb.sendRecvStop = sendRecvCancel
	go func() {
		err := c2s_looptcp.RecvLoop(sendRecvCtx, scb.sendRecvStop, conn,
			readTimeoutSec, scb.handleRecvPacket)
		if err != nil {
			returnerr = fmt.Errorf("end RecvLoop %v", err)
		}
	}()
	go func() {
		err := c2s_looptcp.SendLoop(sendRecvCtx, scb.sendRecvStop, conn,
			writeTimeoutSec, scb.sendCh,
			marshalfn, scb.handleSentPacket)
		if err != nil {
			returnerr = fmt.Errorf("end SendLoop %v", err)
		}
	}()
loop:
	for {
		select {
		case <-sendRecvCtx.Done():
			break loop
		}
	}
	return returnerr
}
func (scb *ServeConnByte) handleSentPacket(pk *c2s_packet.Packet) error {
	scb.sendCounter.Inc()
	switch pk.Header.FlowType {
	default:
		return fmt.Errorf("invalid packet type %s %v", scb, pk.Header)

	case c2s_packet.Request:
		return fmt.Errorf("request packet not supported %s %v", scb, pk.Header)

	case c2s_packet.Response:
		statOjb := scb.pid2ApiStatObj.Del(pk.Header.ID)
		if statOjb != nil {
			statOjb.AfterSendRsp(pk.Header)
		} else {
			return fmt.Errorf("send StatObj not found %v", pk.Header)
		}
	case c2s_packet.Notification:
		scb.notiStat.Add(pk.Header)
	}
	return nil
}
func (scb *ServeConnByte) handleRecvPacket(rheader c2s_packet.Header, rbody []byte) error {
	scb.recvCounter.Inc()
	if rheader.FlowType != c2s_packet.Request {
		return fmt.Errorf("Unexpected rheader packet type: %v", rheader)
	}
	if int(rheader.Cmd) >= len(scb.demuxReq2BytesAPIFnMap) {
		return fmt.Errorf("Invalid rheader command %v", rheader)
	}
	if !scb.authorCmdList.CheckAuth(c2s_idcmd.CommandID(rheader.Cmd)) {
		return fmt.Errorf("Not authorized packet %v", rheader)
	}

	statObj, err := scb.apiStat.AfterRecvReqHeader(rheader)
	if err != nil {
		return err
	}
	if err := scb.pid2ApiStatObj.Add(rheader.ID, statObj); err != nil {
		return err
	}
	statObj.BeforeAPICall()

	var sheader c2s_packet.Header
	var sbody interface{}
	var apierr error
	if c2s_const.ServerAPICallTimeOutDur != 0 {
		// timeout api call
		apiResult := scb.callAPI_timed(rheader, rbody)
		sheader, sbody, apierr = apiResult.header, apiResult.body, apiResult.err
	} else {
		// no timeout api call
		fn := scb.demuxReq2BytesAPIFnMap[rheader.Cmd]
		sheader, sbody, apierr = fn(scb, rheader, rbody)
	}

	statObj.AfterAPICall()

	scb.errorStat.Inc(c2s_idcmd.CommandID(rheader.Cmd), sheader.ErrorCode)
	if apierr != nil {
		return apierr
	}
	if sbody == nil {
		return fmt.Errorf("Response body nil")
	}
	sheader.FlowType = c2s_packet.Response
	sheader.Cmd = rheader.Cmd
	sheader.ID = rheader.ID
	rpk := &c2s_packet.Packet{
		Header: sheader,
		Body:   sbody,
	}
	return scb.EnqueueSendPacket(rpk)
}

type callAPIResult struct {
	header c2s_packet.Header
	body   interface{}
	err    error
}

func (scb *ServeConnByte) callAPI_timed(rheader c2s_packet.Header, rbody []byte) callAPIResult {
	rtnCh := make(chan callAPIResult, 1)
	go func(rtnCh chan callAPIResult, rheader c2s_packet.Header, rbody []byte) {
		fn := scb.demuxReq2BytesAPIFnMap[rheader.Cmd]
		sheader, sbody, apierr := fn(scb, rheader, rbody)
		rtnCh <- callAPIResult{sheader, sbody, apierr}
	}(rtnCh, rheader, rbody)
	timeoutTk := time.NewTicker(c2s_const.ServerAPICallTimeOutDur)
	defer timeoutTk.Stop()
	select {
	case apiResult := <-rtnCh:
		return apiResult
	case <-timeoutTk.C:
		return callAPIResult{rheader, nil, fmt.Errorf("APICall Timeout %v", rheader)}
	}
}
func (scb *ServeConnByte) EnqueueSendPacket(pk *c2s_packet.Packet) error {
	select {
	case scb.sendCh <- pk:
		return nil
	default:
		return fmt.Errorf("Send channel full %v", scb)
	}
}
func (scb *ServeConnByte) SendNotiPacket(
	cmd c2s_idnoti.NotiID, body interface{}) error {
	err := scb.EnqueueSendPacket(&c2s_packet.Packet{
		c2s_packet.Header{
			Cmd:      uint16(cmd),
			FlowType: c2s_packet.Notification,
		},
		body,
	})
	if err != nil {
		scb.Disconnect()
	}
	return err
}
